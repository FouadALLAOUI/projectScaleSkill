# NextJS Continuous Integration Pipeline
# This pipeline builds, tests, and packages the application for deployment
# Triggers only manually or from successful PR pipeline completions
# Reference: https://docs.microsoft.com/azure/devops/pipelines/languages/javascript

name: 'CI_Pipeline_for_ProjectScaleSkill_App'

#trigger: none  # No direct commit triggers
pr: none  # No PR triggers (handled by PR pipeline)

# Pipeline resource dependency - only run after successful PR pipeline completion
#resources:
#  pipelines:
#  - pipeline: PR_Pipeline  # Reference to PR pipeline
#    source: PR_Pipeline_for_ProjectScaleSkill_App  # PR pipeline name
#    trigger: 
#      branches:
#        include:
#          - main  # Only trigger on successful PR merges to master

# Agent pool configuration
pool:
  name: PoolRunners  # Specify the pool of agents to run the jobs

# Global variables for the pipeline
variables:
  # Docker image configuration
  IMAGE_NAME: 'projectscaleskill'
  ACR_NAME: 'acrprojectscaleskill'
  DOCKER_IMAGE_TAG: $(Build.BuildID)
  REGISTRY_NAME: 'acrprojectscaleskill'
  # Node.js configuration - updated to match package.json requirements
  NODE_VERSION: '18.x'
  # Control npm output level (silent, error, warn, notice, http, timing, info, verbose, silly)
  NPM_VERBOSITY: 'verbose'
  # Npm cache directory to improve build performance and enable cache clearing
  NPM_CACHE_FOLDER: $(Pipeline.Workspace)/.npm

# Pipeline stages
stages:
# STAGE 1: Validate and build the application
- stage: validation
  displayName: 'Application Validation & Build'
  jobs:
  - job: BuildAndPackage
    displayName: 'Build and Package NextJS Application'
    steps:
    # Step 1: Setup Node.js environment
    - task: NodeTool@0
      inputs:
        versionSpec: $(NODE_VERSION)
      displayName: 'Setup Node.js Environment'
    
    # Step 2: Verify environment and clear npm cache if needed
    - script: |
        echo "##[section]Diagnosing environment..."
        echo "Node version: $(node --version)"
        echo "Npm version: $(npm --version)"
        echo "OS information: $(uname -a)"
        
        echo "##[section]Clearing npm cache..."
        npm cache clean --force
        
        echo "##[section]Verifying package.json..."
        cat package.json
      displayName: 'Verify Environment and Clean Cache'
    
    # Step 3: Install dependencies with robust error handling
    - script: |
        echo "##[section]Installing dependencies..."
        # Using legacy-peer-deps to handle dependency conflicts between react-three packages
        npm install --legacy-peer-deps
      displayName: 'Install Dependencies'
    
    # Step 4: Run linting with auto-fix and continue on error
    - script: |
        echo "##[section]Running code quality checks..."
        npm run lint --force -- --fix || echo "Linting issues found, but continuing pipeline"
      displayName: 'Static Code Analysis'
      continueOnError: true  # Allow pipeline to continue even if linting issues are found
    
    # Step 5: Security vulnerability scanning
    - script: |
        echo "##[section]Running security audit..."
        npm audit --production || echo "Security issues found, but continuing pipeline"
      displayName: 'Security Vulnerability Scan'
      continueOnError: true  # Allow pipeline to continue even if vulnerabilities are found

    # Step 6: Run unit tests
    - script: |
        echo "##[section]Running unit tests..."
        npm run test
      displayName: 'Unit Tests'
      continueOnError: true  # Allow pipeline to continue even if tests fail

    # Step 7: Linting with ESLint
    - script: |
        echo "##[section]Running ESLint..."
        npm run lint
      displayName: 'ESLint'
      continueOnError: true  # Allow pipeline to continue even if linting issues are found

    # Step 8: Formatting with Prettier
    - script: |
        echo "##[section]Running Prettier..."
        npm run format
      displayName: 'Prettier'
      continueOnError: true  # Allow pipeline to continue even if formatting issues are found

    # Step 9: Build application and prepare deployment package
    - script: |
        echo "##[section]Building application..."
        # Use --legacy-peer-deps for build as well to maintain consistency
        npm run build --legacy-peer-deps
        
        echo "##[section]Creating optimized deployment package..."
        mkdir -p $(Build.ArtifactStagingDirectory)/app
        
        # Copy only essential Next.js build files (exclude cache)
        cp -R .next/static $(Build.ArtifactStagingDirectory)/app/.next/
        cp -R .next/server $(Build.ArtifactStagingDirectory)/app/.next/
        cp .next/BUILD_ID $(Build.ArtifactStagingDirectory)/app/.next/ 2>/dev/null || true
        cp .next/export-marker.json $(Build.ArtifactStagingDirectory)/app/.next/ 2>/dev/null || true
        cp .next/package.json $(Build.ArtifactStagingDirectory)/app/.next/ 2>/dev/null || true
        cp .next/prerender-manifest.json $(Build.ArtifactStagingDirectory)/app/.next/ 2>/dev/null || true
        cp .next/routes-manifest.json $(Build.ArtifactStagingDirectory)/app/.next/ 2>/dev/null || true
        cp .next/images-manifest.json $(Build.ArtifactStagingDirectory)/app/.next/ 2>/dev/null || true
        
        # Copy package files and public directory
        cp package*.json $(Build.ArtifactStagingDirectory)/app/
        cp -R public $(Build.ArtifactStagingDirectory)/app/ 2>/dev/null || true
        
        # Create next.config.js if it exists
        cp next.config.js $(Build.ArtifactStagingDirectory)/app/ 2>/dev/null || true
        
        echo "##[section]Verifying deployment package size..."
        du -sh $(Build.ArtifactStagingDirectory)/app || true
        echo "##[section]Package contents:"
        find $(Build.ArtifactStagingDirectory)/app -type f | head -20
        echo "Optimized deployment package created successfully."
      displayName: 'Build and Package Application'

    # Additional verification to ensure no cache files are included
    - script: |
        echo "##[section]Final package verification..."
        
        # Check total package size
        PACKAGE_SIZE=$(du -sh $(Build.ArtifactStagingDirectory)/app | cut -f1)
        echo "Total package size: $PACKAGE_SIZE"
        
        # Verify no cache directories exist
        CACHE_COUNT=$(find $(Build.ArtifactStagingDirectory)/app -name "*cache*" -type d | wc -l)
        if [ $CACHE_COUNT -gt 0 ]; then
          echo "##[error]ERROR: Cache directories found in deployment package!"
          find $(Build.ArtifactStagingDirectory)/app -name "*cache*" -type d
          exit 1
        else
          echo "✓ No cache directories found in deployment package"
        fi
        
        # Verify no .pack files exist (webpack cache files)
        PACK_COUNT=$(find $(Build.ArtifactStagingDirectory)/app -name "*.pack" | wc -l)
        if [ $PACK_COUNT -gt 0 ]; then
          echo "##[error]ERROR: Webpack pack files found in deployment package!"
          find $(Build.ArtifactStagingDirectory)/app -name "*.pack"
          exit 1
        else
          echo "✓ No webpack pack files found in deployment package"
        fi
        
        # Show final directory structure
        echo "##[section]Final deployment package structure:"
        tree $(Build.ArtifactStagingDirectory)/app -L 3 2>/dev/null || find $(Build.ArtifactStagingDirectory)/app -type d | head -15
        
        echo "##[section]✓ Package verification completed successfully"
      displayName: 'Verify Package Contents and Size'

    # Step 7: Publish build artifacts
    - task: PublishBuildArtifacts@1
      inputs:
        pathToPublish: $(Build.ArtifactStagingDirectory)
        artifactName: 'NextjsBuild'
        publishLocation: 'Container'
      displayName: 'Publish Build Artifacts'
      
    # Step 8: Publish security reports as artifacts
    - script: |
        echo "##[section]Running enhanced security scanning..."
        npm audit --production --json > $(Build.ArtifactStagingDirectory)/npm-audit.json || true
        echo "##[section]Summary of security findings:"
        npm audit --production --audit-level=moderate || echo "Security issues found, but continuing pipeline"
      displayName: 'Comprehensive Security Analysis'
      continueOnError: true
      
    - task: PublishBuildArtifacts@1
      inputs:
        pathToPublish: $(Build.ArtifactStagingDirectory)
        artifactName: 'SecurityReports'
        publishLocation: 'Container'
      displayName: 'Publish Security Reports'
      condition: succeededOrFailed()  # Run even if previous steps failed


# STAGE 2: Security Testing (SAST & DAST)
- stage: SecurityTesting
  displayName: 'Security Testing (SAST & DAST)'
  dependsOn: validation
  condition: succeeded('validation')
  variables:
    # Security testing configuration
    SECURITY_SCAN_TIMEOUT: 30 # minutes
    FAIL_ON_CRITICAL: true
    FAIL_ON_HIGH: false
    SECURITY_REPORTS_PATH: '$(Build.ArtifactStagingDirectory)/security-reports'
  jobs:
  
  # SAST (Static Application Security Testing)
  - job: StaticSecurityAnalysis
    displayName: 'SAST - Static Application Security Testing'
    timeoutInMinutes: $(SECURITY_SCAN_TIMEOUT)
    cancelTimeoutInMinutes: 5
    
    steps:
    # Setup Node.js environment for security tools
    - task: NodeTool@0
      inputs:
        versionSpec: $(NODE_VERSION)
      displayName: 'Setup Node.js Environment'

    # Create security reports directory structure
    - script: |
        echo "##[section]Creating security reports directory structure..."
        mkdir -p $(SECURITY_REPORTS_PATH)/{npm,eslint,retire,semgrep,njsscan,secrets,summary}
        echo "Directory structure created successfully"
      displayName: 'Initialize Security Reports Structure'

    # Install dependencies for security scanning
    - script: |
        echo "##[section]Installing dependencies for comprehensive security analysis..."
        echo "Node.js version: $(node --version)"
        echo "npm version: $(npm --version)"
        
        # Install with better error handling
        npm ci --legacy-peer-deps || npm install --legacy-peer-deps
        
        echo "##[section]Verifying critical dependencies..."
        npm list --depth=0 | grep -E "(next|react|typescript)" || echo "Core dependencies verification completed"
      displayName: 'Install Dependencies for Security Analysis'
      
    # Enhanced dependency vulnerability scanning
    - script: |
        echo "##[section]Running comprehensive dependency vulnerability analysis..."
        
        # Full dependency audit
        echo "##[subsection]Full dependency vulnerability scan..."
        npm audit --json > $(SECURITY_REPORTS_PATH)/npm/audit-full.json 2>/dev/null || true
        npm audit --audit-level=moderate > $(SECURITY_REPORTS_PATH)/npm/audit-summary.txt 2>&1 || echo "Vulnerabilities detected"
        
        # Production-only audit
        echo "##[subsection]Production dependency vulnerability scan..."
        npm audit --production --json > $(SECURITY_REPORTS_PATH)/npm/audit-production.json 2>/dev/null || true
        
        # Critical and high severity check
        echo "##[subsection]Critical and high severity vulnerability check..."
        CRITICAL_COUNT=$(npm audit --json 2>/dev/null | jq -r '.metadata.vulnerabilities.critical // 0')
        HIGH_COUNT=$(npm audit --json 2>/dev/null | jq -r '.metadata.vulnerabilities.high // 0')
        
        echo "Critical vulnerabilities: $CRITICAL_COUNT"
        echo "High vulnerabilities: $HIGH_COUNT"
        echo "##vso[task.setvariable variable=CriticalVulns]$CRITICAL_COUNT"
        echo "##vso[task.setvariable variable=HighVulns]$HIGH_COUNT"
        
        # Package information
        echo "##[subsection]Gathering package information..."
        npm outdated --json > $(SECURITY_REPORTS_PATH)/npm/outdated.json 2>/dev/null || true
        npm list --depth=0 --json > $(SECURITY_REPORTS_PATH)/npm/dependencies-tree.json 2>/dev/null || true
        
        # License audit
        echo "##[subsection]License compatibility check..."
        npm list --depth=0 --json | jq -r '.dependencies | to_entries[] | select(.value.licenses) | "\(.key): \(.value.licenses)"' > $(SECURITY_REPORTS_PATH)/npm/licenses.txt 2>/dev/null || echo "License information gathered"
        
        echo "Dependency vulnerability analysis completed"
      displayName: 'Comprehensive Dependency Vulnerability Analysis'
      continueOnError: true

    # Professional ESLint Security Analysis
    - script: |
        echo "##[section]Installing and configuring ESLint security analysis..."
        
        # Install security plugins with specific versions for consistency
        echo "##[subsection]Installing ESLint security plugins..."
        npm install --no-save \
          eslint-plugin-security@^3.0.1 \
          eslint-plugin-no-secrets@^1.0.2 \
          @typescript-eslint/eslint-plugin@^7.0.0 \
          @typescript-eslint/parser@^7.0.0 \
          eslint-plugin-react-hooks@^4.6.0 \
          eslint-plugin-jsx-a11y@^6.8.0 || echo "Some plugins may have failed to install"
        
        # Verify ESLint security configuration exists
        if [ ! -f ".eslintrc-security.json" ]; then
          echo "##[subsection]Creating enterprise-grade ESLint security configuration..."
          cat > .eslintrc-security.json << 'EOF'
          {
            "env": {
              "browser": true,
              "node": true,
              "es2022": true
            },
            "extends": [
              "eslint:recommended",
              "@typescript-eslint/recommended"
            ],
            "plugins": [
              "security",
              "no-secrets",
              "@typescript-eslint",
              "react-hooks",
              "jsx-a11y"
            ],
            "parser": "@typescript-eslint/parser",
            "parserOptions": {
              "ecmaVersion": 2022,
              "sourceType": "module",
              "ecmaFeatures": {
                "jsx": true
              }
            },
            "rules": {
              "security/detect-buffer-noassert": "error",
              "security/detect-child-process": "error",
              "security/detect-disable-mustache-escape": "error",
              "security/detect-eval-with-expression": "error",
              "security/detect-no-csrf-before-method-override": "error",
              "security/detect-non-literal-fs-filename": "warn",
              "security/detect-non-literal-regexp": "warn",
              "security/detect-non-literal-require": "warn",
              "security/detect-object-injection": "error",
              "security/detect-possible-timing-attacks": "error",
              "security/detect-pseudoRandomBytes": "error",
              "security/detect-unsafe-regex": "error",
              "no-secrets/no-secrets": "error",
              "no-eval": "error",
              "no-implied-eval": "error",
              "no-new-func": "error",
              "no-script-url": "error"
            }
          }
          EOF
        fi
        
        echo "##[subsection]Running ESLint security analysis..."
        npx eslint --ext .js,.jsx,.ts,.tsx,.mjs,.cjs \
          --config .eslintrc-security.json \
          --format json \
          --output-file $(SECURITY_REPORTS_PATH)/eslint/security-analysis.json \
          --ignore-path .gitignore \
          . || echo "ESLint security analysis completed with findings"
        
        # Generate human-readable report
        npx eslint --ext .js,.jsx,.ts,.tsx,.mjs,.cjs \
          --config .eslintrc-security.json \
          --format stylish \
          --ignore-path .gitignore \
          . > $(SECURITY_REPORTS_PATH)/eslint/security-report.txt 2>&1 || echo "Security report generated"
        
        # Count security issues
        SECURITY_ISSUES=$(jq -r '[.[].messages[]] | length' $(SECURITY_REPORTS_PATH)/eslint/security-analysis.json 2>/dev/null || echo "0")
        echo "##vso[task.setvariable variable=SecurityIssues]$SECURITY_ISSUES"
        echo "ESLint security issues found: $SECURITY_ISSUES"
        
      displayName: 'Professional ESLint Security Analysis'
      continueOnError: true

    # Enhanced Retire.js Analysis
    - script: |
        echo "##[section]Installing and running Retire.js vulnerability scanner..."
        
        # Install specific version for consistency
        npm install -g retire@^5.0.0 || echo "Retire.js installation failed"
        
        if command -v retire >/dev/null 2>&1; then
          echo "##[subsection]Running Retire.js vulnerability scan..."
          retire --version || echo "Version check failed"
          
          # Run with JSON output
          retire --outputformat json \
            --outputpath $(SECURITY_REPORTS_PATH)/retire/vulnerabilities.json \
            --ignore ignore.json \
            . || echo "Retire.js found potential vulnerabilities"
          
          # Run with readable output
          retire --outputformat text \
            --outputpath $(SECURITY_REPORTS_PATH)/retire/vulnerabilities.txt \
            . || echo "Retire.js scan completed"
          
          # Count vulnerabilities
          RETIRE_VULNS=$(jq -r '[.[] | select(.results)] | length' $(SECURITY_REPORTS_PATH)/retire/vulnerabilities.json 2>/dev/null || echo "0")
          echo "##vso[task.setvariable variable=RetireVulns]$RETIRE_VULNS"
          echo "Retire.js vulnerabilities found: $RETIRE_VULNS"
        else
          echo "##[warning]Retire.js not available, skipping scan"
          echo '{"error": "Retire.js not available"}' > $(SECURITY_REPORTS_PATH)/retire/vulnerabilities.json
        fi
      displayName: 'Enhanced Retire.js Vulnerability Scanner'
      continueOnError: true

    # Professional Semgrep Analysis
    - script: |
        echo "##[section]Installing and running Semgrep static analysis..."
        
        # Install Semgrep with proper error handling
        echo "##[subsection]Installing Semgrep..."
        if command -v python3 >/dev/null 2>&1; then
          python3 -m pip install --user semgrep || echo "Semgrep pip installation failed"
        fi
        
        # Try alternative installation methods
        if ! command -v semgrep >/dev/null 2>&1; then
          echo "Trying alternative Semgrep installation..."
          curl -fsSL https://semgrep.dev/install | bash || echo "Direct installation failed"
        fi
        
        if command -v semgrep >/dev/null 2>&1; then
          echo "##[subsection]Running comprehensive Semgrep analysis..."
          semgrep --version
          
          # Auto-detection scan
          semgrep --config=auto \
            --json \
            --output=$(SECURITY_REPORTS_PATH)/semgrep/auto-scan.json \
            --timeout=300 \
            --max-target-bytes=5000000 \
            . || echo "Auto-scan completed with findings"
          
          # Specific ruleset scans
          echo "##[subsection]Running targeted security scans..."
          semgrep --config=p/security-audit \
            --config=p/secrets \
            --config=p/javascript \
            --config=p/typescript \
            --config=p/react \
            --json \
            --output=$(SECURITY_REPORTS_PATH)/semgrep/security-focused.json \
            . || echo "Security-focused scan completed"
          
          # Generate summary report
          semgrep --config=auto \
            --output=$(SECURITY_REPORTS_PATH)/semgrep/summary.txt \
            . || echo "Summary report generated"
          
          # Count findings
          SEMGREP_FINDINGS=$(jq -r '.results | length' $(SECURITY_REPORTS_PATH)/semgrep/auto-scan.json 2>/dev/null || echo "0")
          echo "##vso[task.setvariable variable=SemgrepFindings]$SEMGREP_FINDINGS"
          echo "Semgrep findings: $SEMGREP_FINDINGS"
        else
          echo "##[warning]Semgrep not available, creating placeholder report"
          echo '{"error": "Semgrep not available", "results": []}' > $(SECURITY_REPORTS_PATH)/semgrep/auto-scan.json
        fi
      displayName: 'Professional Semgrep Static Analysis'
      continueOnError: true

    # Secret Detection Suite
    - script: |
        echo "##[section]Running comprehensive secret detection..."
        
        # Method 1: TruffleHog (if available)
        echo "##[subsection]Installing TruffleHog..."
        if command -v python3 >/dev/null 2>&1; then
          python3 -m pip install --user truffleHog || echo "TruffleHog installation failed"
        fi
        
        if command -v trufflehog >/dev/null 2>&1; then
          echo "Running TruffleHog secret detection..."
          trufflehog --json --output $(SECURITY_REPORTS_PATH)/secrets/trufflehog.json . || echo "TruffleHog scan completed"
        else
          echo "TruffleHog not available, using alternative methods"
        fi
        
        # Method 2: GitLeaks-style pattern detection
        echo "##[subsection]Running pattern-based secret detection..."
        
        # Create comprehensive secret patterns
        cat > /tmp/secret-patterns.txt << 'EOF'
        # API Keys and Tokens
        (api[_-]?key|apikey)[[:space:]]*[:=][[:space:]]*['"'"'"]?[a-zA-Z0-9_-]{20,}['"'"'"]?
        (secret[_-]?key|secretkey)[[:space:]]*[:=][[:space:]]*['"'"'"]?[a-zA-Z0-9_-]{20,}['"'"'"]?
        (access[_-]?token|accesstoken)[[:space:]]*[:=][[:space:]]*['"'"'"]?[a-zA-Z0-9_-]{20,}['"'"'"]?
        (auth[_-]?token|authtoken)[[:space:]]*[:=][[:space:]]*['"'"'"]?[a-zA-Z0-9_-]{20,}['"'"'"]?
        
        # Database URLs
        (database[_-]?url|db[_-]?url)[[:space:]]*[:=][[:space:]]*['"'"'"]?[a-zA-Z0-9+]+://[^[:space:]'"'"'"]+['"'"'"]?
        mongodb://[^[:space:]'"'"'"]+
        postgres://[^[:space:]'"'"'"]+
        mysql://[^[:space:]'"'"'"]+
        
        # AWS Keys
        AKIA[0-9A-Z]{16}
        aws[_-]?secret[_-]?access[_-]?key[[:space:]]*[:=][[:space:]]*['"'"'"]?[a-zA-Z0-9/+=]{40}['"'"'"]?
        
        # Other sensitive patterns
        (password|passwd|pwd)[[:space:]]*[:=][[:space:]]*['"'"'"]?[^[:space:]{'"'"'"][^[:space:]'"'"'"]*['"'"'"]?
        (private[_-]?key|privatekey)[[:space:]]*[:=]
        -----BEGIN[[:space:]]+(RSA[[:space:]]+)?PRIVATE[[:space:]]+KEY-----
        EOF
        
        # Run pattern detection
        grep -r -n -H -i -f /tmp/secret-patterns.txt \
          --include="*.js" --include="*.ts" --include="*.jsx" --include="*.tsx" \
          --include="*.json" --include="*.yml" --include="*.yaml" \
          --include="*.env*" --include="*.config.*" \
          --exclude-dir=node_modules --exclude-dir=.git --exclude-dir=dist --exclude-dir=build \
          . > $(SECURITY_REPORTS_PATH)/secrets/pattern-detection.txt 2>/dev/null || echo "Pattern detection completed"
        
        # Count potential secrets
        SECRET_COUNT=$(wc -l < $(SECURITY_REPORTS_PATH)/secrets/pattern-detection.txt 2>/dev/null || echo "0")
        echo "##vso[task.setvariable variable=SecretCount]$SECRET_COUNT"
        echo "Potential secrets detected: $SECRET_COUNT"
        
        # Environment variable audit
        echo "##[subsection]Environment variable usage audit..."
        grep -r -n -H "process\.env\." \
          --include="*.js" --include="*.ts" --include="*.jsx" --include="*.tsx" \
          --exclude-dir=node_modules --exclude-dir=.git \
          . > $(SECURITY_REPORTS_PATH)/secrets/env-usage.txt 2>/dev/null || echo "Environment variable audit completed"
        
        rm -f /tmp/secret-patterns.txt
      displayName: 'Comprehensive Secret Detection Suite'
      continueOnError: true

    # Generate Security Summary Report
    - script: |
        echo "##[section]Generating comprehensive security summary..."
        
        # Create detailed security summary
        cat > $(SECURITY_REPORTS_PATH)/summary/security-summary.md << 'EOF'
        # Security Analysis Summary Report
        
        ## Overview
        This report provides a comprehensive overview of the security analysis performed on the codebase.
        
        ## Vulnerability Summary
        - **Critical Vulnerabilities**: $(CriticalVulns)
        - **High Vulnerabilities**: $(HighVulns)  
        - **ESLint Security Issues**: $(SecurityIssues)
        - **Retire.js Vulnerabilities**: $(RetireVulns)
        - **Semgrep Findings**: $(SemgrepFindings)
        - **Potential Secrets**: $(SecretCount)
        
        ## Analysis Details
        
        ### Dependency Vulnerabilities
        - Full audit results: `npm/audit-full.json`
        - Production audit: `npm/audit-production.json`
        - Outdated packages: `npm/outdated.json`
        
        ### Static Code Analysis
        - ESLint security analysis: `eslint/security-analysis.json`
        - Semgrep findings: `semgrep/auto-scan.json`
        - Retire.js vulnerabilities: `retire/vulnerabilities.json`
        
        ### Secret Detection
        - Pattern-based detection: `secrets/pattern-detection.txt`
        - Environment variable usage: `secrets/env-usage.txt`
        
        ## Recommendations
        1. Review and address all critical and high severity vulnerabilities
        2. Update outdated packages to latest secure versions
        3. Fix ESLint security issues identified in the report
        4. Verify and secure any detected secrets or sensitive information
        5. Implement proper environment variable management
        
        ## Report Generation
        - Generated: $(date)
        - Pipeline: $(Build.DefinitionName)
        - Build: $(Build.BuildNumber)
        EOF
        
        # Replace variables in the summary
        sed -i "s/\$(CriticalVulns)/${CriticalVulns:-0}/g" $(SECURITY_REPORTS_PATH)/summary/security-summary.md
        sed -i "s/\$(HighVulns)/${HighVulns:-0}/g" $(SECURITY_REPORTS_PATH)/summary/security-summary.md
        sed -i "s/\$(SecurityIssues)/${SecurityIssues:-0}/g" $(SECURITY_REPORTS_PATH)/summary/security-summary.md
        sed -i "s/\$(RetireVulns)/${RetireVulns:-0}/g" $(SECURITY_REPORTS_PATH)/summary/security-summary.md
        sed -i "s/\$(SemgrepFindings)/${SemgrepFindings:-0}/g" $(SECURITY_REPORTS_PATH)/summary/security-summary.md
        sed -i "s/\$(SecretCount)/${SecretCount:-0}/g" $(SECURITY_REPORTS_PATH)/summary/security-summary.md
        
        echo "##[section]Security analysis summary:"
        echo "Critical vulnerabilities: ${CriticalVulns:-0}"
        echo "High vulnerabilities: ${HighVulns:-0}"
        echo "ESLint security issues: ${SecurityIssues:-0}"
        echo "Retire.js vulnerabilities: ${RetireVulns:-0}"
        echo "Semgrep findings: ${SemgrepFindings:-0}"
        echo "Potential secrets: ${SecretCount:-0}"
        
        # Set overall security status
        TOTAL_CRITICAL=$((${CriticalVulns:-0} + ${SecurityIssues:-0}))
        if [ "$TOTAL_CRITICAL" -gt 0 ]; then
          echo "##vso[task.setvariable variable=SecurityStatus]CRITICAL"
          echo "##[warning]Critical security issues detected!"
        elif [ "${HighVulns:-0}" -gt 0 ]; then
          echo "##vso[task.setvariable variable=SecurityStatus]HIGH"
          echo "##[warning]High severity security issues detected!"
        else
          echo "##vso[task.setvariable variable=SecurityStatus]PASSED"
          echo "##[section]Security analysis passed without critical issues"
        fi
      displayName: 'Generate Security Summary Report'
      
    # Security Gate Check
    - script: |
        echo "##[section]Security gate evaluation..."
        
        if [ "${SecurityStatus}" = "CRITICAL" ] && [ "$(FAIL_ON_CRITICAL)" = "true" ]; then
          echo "##[error]Security gate failed: Critical vulnerabilities detected"
          echo "##[error]Critical vulnerabilities: ${CriticalVulns:-0}"
          echo "##[error]Critical ESLint issues: ${SecurityIssues:-0}"
          exit 1
        elif [ "${SecurityStatus}" = "HIGH" ] && [ "$(FAIL_ON_HIGH)" = "true" ]; then
          echo "##[error]Security gate failed: High severity vulnerabilities detected"
          echo "##[error]High vulnerabilities: ${HighVulns:-0}"
          exit 1
        else
          echo "##[section]Security gate passed"
          echo "Security status: ${SecurityStatus}"
        fi
      displayName: 'Security Gate Evaluation'
      condition: always()

    # Publish comprehensive security reports
    - task: PublishBuildArtifacts@1
      inputs:
        pathToPublish: $(SECURITY_REPORTS_PATH)
        artifactName: 'Security-Analysis-Reports'
        publishLocation: 'Container'
      displayName: 'Publish Security Analysis Reports'
      condition: always()
      
    # Publish security test results
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '$(SECURITY_REPORTS_PATH)/**/*.xml'
        failTaskOnFailedTests: false
        testRunTitle: 'Security Analysis Results'
      displayName: 'Publish Security Test Results'
      condition: and(always(), eq(variables['Agent.OS'], 'Linux'))
      continueOnError: true


#  # DAST (Dynamic Application Security Testing)
#  - job: DynamicSecurityAnalysis
#    displayName: 'DAST - Dynamic Application Security Testing'
#    dependsOn: StaticSecurityAnalysis
#    steps:
#    # Setup Node.js environment
#    - task: NodeTool@0
#      inputs:
#        versionSpec: $(NODE_VERSION)
#      displayName: 'Setup Node.js Environment'
#
#    # Install dependencies and build application
#    - script: |
#        echo "##[section]Installing dependencies..."
#        npm install --legacy-peer-deps
#        
#        echo "##[section]Building application for DAST testing..."
#        npm run build
#      displayName: 'Build Application for DAST'
#
#    # Start application for dynamic testing
#    - script: |
#        echo "##[section]Starting Next.js application for DAST..."
#        npm start &
#        APP_PID=$!
#        echo "Application PID: $APP_PID"
#        echo $APP_PID > $(Build.ArtifactStagingDirectory)/app.pid
#        
#        echo "##[section]Waiting for application to start..."
#        sleep 30
#        
#        echo "##[section]Verifying application is running..."
#        curl -f http://localhost:3000 || echo "Application may not be fully ready"
#      displayName: 'Start Application for Testing'
#      continueOnError: true
#
#    # Install and run OWASP ZAP for web security testing
#    - script: |
#        echo "##[section]Installing OWASP ZAP..."
#        # Download and setup ZAP
#        wget -q https://github.com/zaproxy/zaproxy/releases/download/v2.14.0/ZAP_2_14_0_unix.sh -O /tmp/zap-installer.sh || echo "Failed to download ZAP"
#        chmod +x /tmp/zap-installer.sh || true
#        /tmp/zap-installer.sh -q || echo "ZAP installation may have failed"
#        
#        echo "##[section]Running OWASP ZAP baseline scan..."
#        # Run ZAP baseline scan against the running application
#        docker run -t owasp/zap2docker-stable zap-baseline.py -t http://host.docker.internal:3000 -J $(Build.ArtifactStagingDirectory)/zap-baseline-report.json || echo "ZAP baseline scan completed"
#        docker run -t owasp/zap2docker-stable zap-baseline.py -t http://host.docker.internal:3000 || echo "ZAP scan found security issues"
#      displayName: 'OWASP ZAP Security Scan'
#      continueOnError: true
#
#    # Run Lighthouse security audit
#    - script: |
#        echo "##[section]Installing Lighthouse..."
#        npm install -g lighthouse || true
#        
#        echo "##[section]Running Lighthouse security audit..."
#        lighthouse http://localhost:3000 --only-categories=best-practices --output=json --output-path=$(Build.ArtifactStagingDirectory)/lighthouse-security.json || true
#        lighthouse http://localhost:3000 --only-categories=best-practices || echo "Lighthouse audit completed"
#      displayName: 'Lighthouse Security Audit'
#      continueOnError: true
#
#    # Web application security headers check
#    - script: |
#        echo "##[section]Checking security headers..."
#        curl -I http://localhost:3000 > $(Build.ArtifactStagingDirectory)/security-headers.txt || true
#        
#        echo "##[section]Analyzing security headers..."
#        python3 -c "
#import requests
#import json
#
#try:
#    response = requests.get('http://localhost:3000')
#    headers = dict(response.headers)
#    
#    security_analysis = {
#        'status_code': response.status_code,
#        'security_headers': {
#            'X-Frame-Options': headers.get('X-Frame-Options', 'MISSING'),
#            'X-Content-Type-Options': headers.get('X-Content-Type-Options', 'MISSING'),
#            'X-XSS-Protection': headers.get('X-XSS-Protection', 'MISSING'),
#            'Strict-Transport-Security': headers.get('Strict-Transport-Security', 'MISSING'),
#            'Content-Security-Policy': headers.get('Content-Security-Policy', 'MISSING'),
#            'Referrer-Policy': headers.get('Referrer-Policy', 'MISSING')
#        },
#        'all_headers': headers
#    }
#    
#    with open('$(Build.ArtifactStagingDirectory)/security-headers-analysis.json', 'w') as f:
#        json.dump(security_analysis, f, indent=2)
#        
#    print('Security Headers Analysis:')
#    for header, value in security_analysis['security_headers'].items():
#        status = '✓' if value != 'MISSING' else '✗'
#        print(f'{status} {header}: {value}')
#        
#except Exception as e:
#    print(f'Error analyzing security headers: {e}')
#" || echo "Security headers analysis completed"
#      displayName: 'Security Headers Analysis'
#      continueOnError: true
#
#    # Stop application
#    - script: |
#        echo "##[section]Stopping application..."
#        if [ -f "$(Build.ArtifactStagingDirectory)/app.pid" ]; then
#          APP_PID=$(cat $(Build.ArtifactStagingDirectory)/app.pid)
#          kill $APP_PID || echo "Application may have already stopped"
#          echo "Application stopped"
#        fi
#      displayName: 'Stop Application'
#      condition: always()
#
#    # Publish DAST artifacts
#    - task: PublishBuildArtifacts@1
#      inputs:
#        pathToPublish: $(Build.ArtifactStagingDirectory)
#        artifactName: 'DAST-Reports'
#        publishLocation: 'Container'
#      displayName: 'Publish DAST Reports'
#      condition: always()
#
#  # Security Summary and Reporting
#  - job: SecuritySummaryReport
#    displayName: 'Security Testing Summary'
#    dependsOn: 
#    - StaticSecurityAnalysis
#    - DynamicSecurityAnalysis
#    steps:
#    # Generate comprehensive security summary
#    - script: |
#        echo "##[section]Generating Security Testing Summary..."
#        
#        echo "=================================="
#        echo "SECURITY TESTING SUMMARY REPORT"
#        echo "=================================="
#        echo "Pipeline: $(Build.DefinitionName)"
#        echo "Build: $(Build.BuildNumber)"
#        echo "Date: $(date)"
#        echo ""
#        
#        echo "SAST (Static Application Security Testing):"
#        echo "- ✓ Dependency vulnerability scanning (npm audit)"
#        echo "- ✓ ESLint security plugin analysis"
#        echo "- ✓ Retire.js known vulnerability scanning"
#        echo "- ✓ Semgrep advanced static analysis"
#        echo "- ✓ njsscan Node.js security analysis"
#        echo "- ✓ TruffleHog secret detection"
#        echo ""
#        
#        echo "DAST (Dynamic Application Security Testing):"
#        echo "- ✓ OWASP ZAP baseline security scan"
#        echo "- ✓ Lighthouse security audit"
#        echo "- ✓ Security headers analysis"
#        echo ""
#        
#        echo "All security reports have been generated and published as pipeline artifacts."
#        echo "Review the detailed reports in the SAST-Reports and DAST-Reports artifacts."
#        echo "=================================="
#      displayName: 'Security Testing Summary'


# STAGE 2: Docker Image Build and Push (commented out but preserved for future use)
#- stage: DockerBuildAndPush
#  displayName: 'Docker Image Build & Publish'
#  dependsOn: validation
#  jobs:
#  - job: BuildAndPushImage
#    displayName: 'Build and Push Docker Image'
#    steps:
#    # Step 1: Build Docker image
#    - script: |
#        echo "##[section]Building Docker image..."
#        docker build --no-cache -t $(IMAGE_NAME):$(DOCKER_IMAGE_TAG) .
#      displayName: 'Build Docker Image'
#
#    # Step 2: Verify image creation
#    - script: |
#        echo "##[section]Verifying Docker images..."
#        docker images
#      displayName: 'List Available Docker Images'
#
#    # Step 3: Tag images for DockerHub
#    - script: |
#        echo "##[section]Tagging Docker image for DockerHub..."
#        docker tag $(IMAGE_NAME):$(DOCKER_IMAGE_TAG) $(DOCKERHUB_USER)/$(IMAGE_NAME):$(DOCKER_IMAGE_TAG)
#        docker tag $(IMAGE_NAME):$(DOCKER_IMAGE_TAG) $(DOCKERHUB_USER)/$(IMAGE_NAME):latest
#      displayName: 'Tag Docker Images'
#
#    # Step 4: Verify tagged images
#    - script: |
#        echo "##[section]Verifying tagged images..."
#        docker images
#      displayName: 'List Tagged Docker Images'
#
#    # Step 5: Push versioned image to DockerHub
#    - task: Docker@2
#      displayName: 'Push Versioned Image to DockerHub'
#      inputs:
#        containerRegistry: 'DockerHub'
#        repository: '$(DOCKERHUB_USER)/$(IMAGE_NAME)'
#        command: 'push'
#        tags: |
#          $(DOCKER_IMAGE_TAG)
#
#    # Step 6: Push latest image to DockerHub
#    - task: Docker@2
#      displayName: 'Push Latest Image to DockerHub'
#      inputs:
#        containerRegistry: 'DockerHub'
#        repository: '$(DOCKERHUB_USER)/$(IMAGE_NAME)'
#        command: 'push'
#        tags: |
#          latest
#
#    # Step 7: Clean up local images
#    - script: |
#        echo "##[section]Cleaning up local images..."
#        docker rmi -f $(IMAGE_NAME):$(DOCKER_IMAGE_TAG) || echo "No images to remove."
#      displayName: 'Clean Up Local Images'
#
#    # Step 8: Success notification
#    - script: |
#        echo "##[section]Docker image successfully built and pushed."
#        echo "Image: $(DOCKERHUB_USER)/$(IMAGE_NAME):$(DOCKER_IMAGE_TAG)"
#      displayName: 'Deployment Summary'
#
#  - job: CleanDockerCache
#    dependsOn: BuildAndPushImage
#    displayName: 'Docker System Maintenance'
#    steps:
#    - script: |
#        echo "##[section]Docker system status before cleanup..."
#        docker system df
#
#        echo "##[section]Cleaning Docker system..."
#        docker system prune -a -f
#        docker image prune -a -f
#        
#        echo "##[section]Docker system status after cleanup..."
#        docker system df
#      displayName: 'Purge Docker Cache'
#
#  - job: PublishImageMetadata
#    dependsOn: CleanDockerCache
#    displayName: 'Publish Deployment Metadata'
#    steps:
#    - script: |
#        echo "##[section]Saving deployment metadata..."
#        echo $(DOCKER_IMAGE_TAG) > $(Build.ArtifactStagingDirectory)/imageTag.txt
#      displayName: 'Generate Deployment Metadata'
#
#    - task: PublishBuildArtifacts@1
#      inputs:
#        pathToPublish: $(Build.ArtifactStagingDirectory)
#        artifactName: 'DeploymentMetadata'
#      displayName: 'Publish Deployment Metadata'

